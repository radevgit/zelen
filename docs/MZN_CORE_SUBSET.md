# MiniZinc Core Subset Specification

**Project**: Zelen - Direct MiniZinc Support  
**Date**: October 15, 2025  
**Status**: Phase 1 MVP Complete ‚úÖ

## Quick Summary

### ‚úÖ What Works Now (Phase 1+ Complete)
- Parse MiniZinc to AST (lexer + recursive descent parser)
- Translate AST directly to Selen Model objects
- Integer variables with domains: `var 1..10: x`
- Boolean variables: `var bool: flag`
- Float variables with domains: `var 0.0..1.0: probability`
- Variable arrays (int, bool, float): `array[1..n] of var 1..n: x`
- Parameters (int, bool, float): `int: n = 5;`, `bool: enabled = true;`, `float: pi = 3.14159;`
- Binary constraints: `x < y`, `x + y <= 10`
- Arithmetic in constraints: `+`, `-`, `*`, `/`, `mod`
- **Boolean logical operations**: `/\` (AND), `\/` (OR), `not` (NOT), `->` (implies), `<->` (iff)
- **Float arithmetic in constraints**: All arithmetic operators work with floats
- **Array indexing in constraints**: `x[i] == value`, `x[1] < 5`
- Global constraint: `alldifferent(queens)`
- Direct execution and solution extraction
- 34 unit tests passing, 7 working examples

### ‚ùå What's Missing (Phase 2)
- Array aggregates: `sum(x)`, `product(x)`, etc.
- Forall loops: `forall(i in 1..n) (...)`
- Element constraint with variable indices: `x[y] == z` (where y is a variable)
- Optimization: `minimize`/`maximize`
- Output formatting
- String types and operations
- Set types and operations

### üìä Test Results
```
‚úÖ 34/34 unit tests passing
‚úÖ Parser handles 6/7 examples (comprehensions Phase 2)
‚úÖ Translator solves simple N-Queens (column constraints)
‚úÖ Boolean logic fully working (AND, OR, NOT, IMPLIES, IFF)
‚úÖ Examples: solve_nqueens, queens4, simple_constraints, compiler_demo, bool_float_demo, boolean_logic_demo
```

## Overview

This document defines the **core subset** of MiniZinc that Zelen supports directly, bypassing FlatZinc compilation. The goal is to support 80% of practical constraint models with 20% of the language complexity.

### Architecture

**New Approach** (Implemented ‚úÖ):
```
MiniZinc Source ‚Üí AST ‚Üí Selen Model ‚Üí Execute & Solve
```

**Previous Approach** (Deprecated):
```
MiniZinc ‚Üí AST ‚Üí String (Rust code) ‚Üí Compile & Run
```

The new architecture builds Selen Model objects directly, enabling:
- ‚úÖ Immediate execution without code generation
- ‚úÖ Runtime model manipulation
- ‚úÖ Direct solution access
- ‚úÖ Better error messages
- ‚úÖ Simpler implementation

### Design Principles

1. **Preserve Structure**: Keep arrays, logical groupings, and semantic meaning ‚úÖ
2. **Incremental Implementation**: Start small, expand based on real needs ‚úÖ
3. **Clear Semantics**: Every feature has well-defined mapping to Selen ‚úÖ
4. **Practical Focus**: Prioritize features used in real models ‚úÖ
5. **Fail Fast**: Reject unsupported features with clear error messages ‚úÖ

## Phase 1: Core Features (MVP) ‚úÖ

### 1.1 Type System

#### Supported Types ‚úÖ

**Scalar Types:**
```minizinc
% Integer variables (unconstrained) - ‚úÖ IMPLEMENTED
var int: count;
par int: n = 10;                      % ‚úÖ Parameters work

% Integer variables with domains - ‚úÖ IMPLEMENTED  
var 1..10: digit;
var 0..n: index;                      % ‚úÖ Expression domains work

% Boolean variables - ‚úÖ IMPLEMENTED
var bool: flag;
par bool: enabled = true;             % ‚úÖ Boolean parameters work

% Float variables with domains - ‚úÖ IMPLEMENTED
var float: unbounded;                 % Unconstrained float
var 0.0..1.0: probability;            % ‚úÖ Float domains work
par float: pi = 3.14159;              % ‚úÖ Float parameters work
```

**Status:**
- ‚úÖ `var int` ‚Üí `model.int(i32::MIN, i32::MAX)`
- ‚úÖ `var 1..10` ‚Üí `model.int(1, 10)`
- ‚úÖ `par int: n = 5` ‚Üí Compile-time evaluation
- ‚úÖ `var 1..n` ‚Üí Domain expressions evaluated with parameters
- ‚úÖ `var bool` ‚Üí `model.bool()`
- ‚úÖ `par bool: b = true` ‚Üí Compile-time evaluation
- ‚úÖ `var float` ‚Üí `model.float(f64::MIN, f64::MAX)`
- ‚úÖ `var 0.0..1.0` ‚Üí `model.float(0.0, 1.0)`
- ‚úÖ `par float: f = 3.14` ‚Üí Compile-time evaluation
- ‚ùå Set domains `{1, 3, 5, 7, 9}` (not yet implemented)

**Array Types:** ‚úÖ
```minizinc
% 1D arrays with integer index sets - ‚úÖ IMPLEMENTED
array[1..n] of var int: x;
array[1..5] of int: constants = [1, 2, 3, 4, 5];

% Arrays with constrained elements - ‚úÖ IMPLEMENTED
array[1..n] of var 1..10: digits;

% Boolean and float arrays - ‚úÖ IMPLEMENTED
array[1..5] of var bool: flags;
array[1..n] of var 0.0..1.0: probabilities;

% Implicitly-indexed arrays - ‚úÖ IMPLEMENTED
array[int] of var 1..4: flags;
array[bool] of var 0..10: choices;
```

**Status:**
- ‚úÖ `array[1..n] of var 1..10` ‚Üí `model.ints(n, 1, 10)`
- ‚úÖ `array[1..n] of var bool` ‚Üí `model.bools(n)`
- ‚úÖ `array[1..n] of var 0.0..1.0` ‚Üí `model.floats(n, 0.0, 1.0)`
- ‚úÖ Index set size calculation from expressions
- ‚úÖ Constrained element domains for all types
- ‚ùå Parameter arrays (not yet implemented)
- ‚ùå Array initialization expressions

#### NOT Supported in Phase 1

- ‚ùå Set domains `var {1, 3, 5, 7, 9}` - Phase 2
- ‚ùå Multi-dimensional arrays - Phase 2
- ‚ùå Enumerated types - Phase 2
- ‚ùå Tuple/Record types - Phase 3
- ‚ùå Option types (`opt int`) - Phase 3
- ‚ùå Set variables (`var set of int`) - Phase 3
- ‚ùå String variables (only for output) - Phase 3

### 1.2 Expressions

#### Arithmetic Expressions ‚úÖ
```minizinc
% Basic operations - ‚úÖ IMPLEMENTED
x + y              % ‚úÖ model.add(x, y)
x - y              % ‚úÖ model.sub(x, y)
x * y              % ‚úÖ model.mul(x, y)
x div y            % ‚úÖ model.div(x, y)
-x                 % ‚úÖ Unary minus

% Comparisons - ‚úÖ IMPLEMENTED in constraints
x < y              % ‚úÖ model.new(x.lt(y))
x <= y             % ‚úÖ model.new(x.le(y))
x > y              % ‚úÖ model.new(x.gt(y))
x >= y             % ‚úÖ model.new(x.ge(y))
x == y             % ‚úÖ model.new(x.eq(y))
x != y             % ‚úÖ model.new(x.ne(y))
```

**Status:**
- ‚úÖ Arithmetic in constraints: `constraint x + y < 15`
- ‚úÖ Nested expressions: `constraint (x + 1) * 2 < y`
- ‚úÖ Integer literals as constants
- ‚úÖ Variable references
- ‚úÖ Parameter references (evaluated at translation time)
- ‚ùå `x mod y` (not yet implemented)
- ‚ùå Arithmetic expressions in variable declarations (e.g., `var x+1..y`)

#### Boolean Expressions ‚ùå
```minizinc
% Logical operations - NOT YET IMPLEMENTED
a /\ b           % AND
a \/ b           % OR
a -> b           % Implication
a <-> b          % Bi-implication
not a            % Negation
a xor b          % Exclusive OR
```

**Status:** Phase 2

#### Array Operations ‚ùå
```minizinc
% Array access - NOT YET IMPLEMENTED
x[i]
x[i+1]

% Array literals - PARSED but not in constraints yet
[1, 2, 3, 4, 5]
[x, y, z]

% Array functions - NOT YET IMPLEMENTED
sum(x)           % Sum of elements
product(x)       % Product of elements
min(x)           % Minimum element
max(x)           % Maximum element
length(x)        % Array length
```

**Status:** Phase 2

#### Set Operations (on fixed sets) ‚ùå
```minizinc
% Set literals - NOT YET IMPLEMENTED
{1, 2, 3}
1..10            % ‚úÖ Used in domains only

% Set membership - NOT YET IMPLEMENTED
x in 1..10
x in {2, 4, 6, 8}

% Set operations - NOT YET IMPLEMENTED
card(1..n)       % Cardinality
min(1..n)        % Minimum
max(1..n)        % Maximum
```

**Status:** Phase 2

### 1.3 Constraints

#### Basic Constraints ‚úÖ
```minizinc
% Relational constraints - ‚úÖ IMPLEMENTED
constraint x < y;               % ‚úÖ model.new(x.lt(y))
constraint x + y == 10;         % ‚úÖ Arithmetic + comparison
constraint x <= y + 5;          % ‚úÖ Complex expressions

% Examples that work:
constraint x < y;               % ‚úÖ
constraint x + y < 15;          % ‚úÖ
constraint x * 2 >= y;          % ‚úÖ
constraint (x + 1) - y != 0;    % ‚úÖ
```

**Status:**
- ‚úÖ Binary comparisons: `<`, `<=`, `>`, `>=`, `==`, `!=`
- ‚úÖ Arithmetic in constraints: `+`, `-`, `*`, `/`
- ‚úÖ Nested expressions
- ‚úÖ Variable and parameter references
- ‚ùå Boolean constraints (`flag1 \/ flag2`) - Phase 2
- ‚ùå Implication (`enabled -> (x > 0)`) - Phase 2
- ‚ùå Array aggregates (`sum(arr) <= 100`) - Phase 2

#### Global Constraints (Priority Order)

**High Priority** ‚úÖ
```minizinc
% All different - ‚úÖ IMPLEMENTED
constraint alldifferent(x);     % ‚úÖ model.alldiff(&x)
constraint all_different(x);    % ‚úÖ Alias supported
```

**Status:**
- ‚úÖ `alldifferent` / `all_different` on arrays
- ‚ùå `element` constraint - Phase 2
- ‚ùå Array indexing in constraints - Phase 2

**Medium Priority** ‚ùå
```minizinc
% NOT YET IMPLEMENTED
constraint cumulative(start, duration, resource, capacity);
constraint table(x, allowed_tuples);
```

**Status:** Phase 2

**Lower Priority** ‚ùå
```minizinc
% NOT YET IMPLEMENTED
constraint sort(x, y);
constraint count(x, value) == n;
constraint global_cardinality(x, cover, counts);
```

**Status:** Phase 2-3

### 1.4 Solve Items

```minizinc
% Satisfaction problem - ‚úÖ IMPLEMENTED
solve satisfy;

% Optimization problems - ‚ùå NOT YET (parsed but not translated)
solve minimize cost;
solve maximize profit;

% With annotations - ‚ùå Phase 2
solve :: int_search(x, input_order, indomain_min) 
      satisfy;
```

**Status:**
- ‚úÖ `solve satisfy` ‚Üí Default solving
- ‚ùå `solve minimize/maximize` ‚Üí Phase 2 (Selen supports it, need to wire up)
- ‚ùå Search annotations ‚Üí Phase 2

### 1.5 Output Items

```minizinc
% Output items - ‚ùå PARSED but IGNORED
output ["x = ", show(x), "\n"];
output ["Solution: ", show(queens), "\n"];
output ["The value is \(x)\n"];
```

**Status:**
- ‚úÖ Parsed (doesn't cause errors)
- ‚ùå Not used (solution extraction done via API)
- ‚ùå Output formatting ‚Üí Phase 2

**Current Approach:**
Solutions are accessed programmatically:
```rust
let translated = Translator::translate_with_vars(&ast)?;
match translated.model.solve() {
    Ok(solution) => {
        if let Some(&x) = translated.int_vars.get("x") {
            println!("x = {:?}", solution[x]);
        }
    }
}
```

### 1.6 Model Structure

```minizinc
% Parameters (fixed at instance-time)
int: n = 10;
array[1..n] of int: weights;

% Decision variables
array[1..n] of var 1..n: queens;

% Constraints
constraint alldifferent(queens);
constraint forall(i in 1..n, j in i+1..n) (
    queens[i] != queens[j] + (j - i) /\
    queens[i] != queens[j] - (j - i)
);

% Solve
solve satisfy;

% Output
output ["queens = \(queens)\n"];
```

## Phase 2: Enhanced Features (After MVP)

### 2.1 Multi-Dimensional Arrays

```minizinc
% 2D arrays (map to 1D internally)
array[1..n, 1..m] of var int: grid;

% Access: grid[i,j] ‚Üí internal_array[i*m + j]
constraint grid[2,3] == 5;
```

**Implementation Strategy:**
- Parse as multi-dimensional
- Flatten to 1D arrays internally
- Translate index expressions: `[i,j]` ‚Üí `[i*dim2 + j]`

### 2.2 Array Comprehensions

```minizinc
% Simple comprehensions
array[int] of var int: doubled = [2*i | i in 1..n];

% With conditions
array[int] of var int: evens = [i | i in 1..n where i mod 2 == 0];

% Generator expressions
constraint forall(i in 1..n) (x[i] > 0);
constraint sum(i in 1..n)(cost[i] * x[i]) <= budget;
```

### 2.3 Enumerated Types

```minizinc
% Enum declaration
enum Color = {Red, Green, Blue};

% Enum variables (map to integers internally)
var Color: my_color;

% Usage
constraint my_color != Red;

% Arrays of enums
array[1..n] of var Color: colors;
```

**Implementation Strategy:**
- Map enum to integer range: `Red=1, Green=2, Blue=3`
- Track mapping for output formatting
- Support `enum2int()` and `to_enum()` functions

### 2.4 Let Expressions

```minizinc
% Local variables
constraint let {
    var int: temp = x + y;
} in temp * 2 > z;

% Multiple locals
constraint let {
    int: half = n div 2;
    var int: mid = x[half];
} in mid > 0;
```

**Implementation Strategy:**
- Introduce fresh variables in parent scope
- Substitute references in body expression
- Handle constraints in let properly

### 2.5 User-Defined Predicates

```minizinc
% Predicate definition
predicate adjacent(var int: x, var int: y) =
    abs(x - y) == 1;

% Usage
constraint adjacent(pos[1], pos[2]);
```

**Implementation Strategy:**
- Inline simple predicates
- Build library of common predicates
- Support recursion carefully (detect cycles)

## Phase 3: Advanced Features (Future)

### 3.1 Set Comprehensions
```minizinc
set of int: evens = {2*i | i in 1..n};
```

### 3.2 Annotations
```minizinc
% Search annotations
solve :: int_search(x, first_fail, indomain_min)
      satisfy;

% Variable annotations
var 1..n: x :: is_defined_var;
```

### 3.3 Option Types
```minizinc
var opt 1..n: maybe_value;
constraint occurs(maybe_value) -> (deopt(maybe_value) > 5);
```

## Mapping to Selen (Actual Implementation)

### Type Mapping ‚úÖ

| MiniZinc | Selen | Status | Notes |
|----------|-------|--------|-------|
| `var int` | `model.int(i32::MIN, i32::MAX)` | ‚úÖ | Unbounded integer |
| `var 1..10` | `model.int(1, 10)` | ‚úÖ | Bounded integer |
| `var 1..n` | `model.int(1, n_value)` | ‚úÖ | Evaluated at translation time |
| `array[1..n] of var int` | `model.ints(n, i32::MIN, i32::MAX)` | ‚úÖ | Integer array |
| `array[1..n] of var 1..10` | `model.ints(n, 1, 10)` | ‚úÖ | Bounded integer array |
| `var bool` | `model.bool()` | ‚ùå | Phase 2 |
| `var float` | `model.float(f64::MIN, f64::MAX)` | ‚ùå | Phase 2 |
| `var 0.0..1.0` | `model.float(0.0, 1.0)` | ‚ùå | Phase 2 |

### Constraint Mapping ‚úÖ

| MiniZinc | Selen | Status | Notes |
|----------|-------|--------|-------|
| `x < y` | `model.new(x.lt(y))` | ‚úÖ | Comparison |
| `x <= y` | `model.new(x.le(y))` | ‚úÖ | Less or equal |
| `x > y` | `model.new(x.gt(y))` | ‚úÖ | Greater than |
| `x >= y` | `model.new(x.ge(y))` | ‚úÖ | Greater or equal |
| `x == y` | `model.new(x.eq(y))` | ‚úÖ | Equality |
| `x != y` | `model.new(x.ne(y))` | ‚úÖ | Not equal |
| `x + y` | `model.add(x, y)` | ‚úÖ | Addition (returns new VarId) |
| `x - y` | `model.sub(x, y)` | ‚úÖ | Subtraction |
| `x * y` | `model.mul(x, y)` | ‚úÖ | Multiplication |
| `x / y` | `model.div(x, y)` | ‚úÖ | Division |
| `alldifferent(x)` | `model.alldiff(&x)` | ‚úÖ | Global constraint |
| `x[i] == value` | - | ‚ùå | Phase 2 (element) |
| `sum(x) <= c` | - | ‚ùå | Phase 2 (linear) |

## Error Handling

### Unsupported Features

When encountering unsupported features, emit clear error messages:

```rust
UnsupportedFeature {
    feature: "multi-dimensional arrays",
    location: "line 15, column 8",
    workaround: "Flatten to 1D: array[1..n*m] of var int",
    phase: "Phase 2"
}
```

### Type Errors

```rust
TypeError {
    expected: "var int",
    found: "set of int",
    location: "line 23, column 12",
    hint: "Set variables not supported in Phase 1"
}
```

### Syntax Errors

```rust
SyntaxError {
    message: "Expected ';' after constraint",
    location: "line 42, column 30",
    context: "constraint x < y"
}
```

## Testing Strategy

### Unit Tests

Test each component in isolation:
- Parser: MiniZinc ‚Üí AST
- Type checker: AST ‚Üí Typed AST
- Compiler: Typed AST ‚Üí Selen code

### Integration Tests

Test complete models:
```rust
#[test]
fn test_nqueens_4() {
    let mzn = r#"
        int: n = 4;
        array[1..n] of var 1..n: queens;
        constraint alldifferent(queens);
        solve satisfy;
    "#;
    
    let compiled = compile_mzn(mzn).unwrap();
    let solution = run_selen(compiled).unwrap();
    assert_eq!(solution.len(), 2); // 2 solutions for 4-queens
}
```

### Benchmark Models

Standard CSP problems:
1. **N-Queens** (various sizes)
2. **Sudoku** (9x9 grid)
3. **Graph Coloring** (various graphs)
4. **Job Shop Scheduling** (simple instances)
5. **Magic Square** (order 3, 4, 5)

## Implementation Status

### Phase 1: Parser & Type System ‚úÖ
- ‚úÖ Lexer (tokenization) - 22 tokens, comments, strings
- ‚úÖ Parser (core subset grammar) - Recursive descent with precedence climbing
- ‚úÖ AST data structures - Model, Item, Expr, TypeInst, etc.
- ‚úÖ Error reporting - Line/column with caret pointers
- ‚ö†Ô∏è Basic type checker - Minimal (type inference TODO)

### Phase 1: Translator & Execution ‚úÖ
- ‚úÖ AST ‚Üí Selen Model translator (not code generation!)
- ‚úÖ Variable mapping - HashMap<String, VarId>
- ‚úÖ Constraint translation - Binary ops and alldifferent
- ‚úÖ Array handling - Vec<VarId> arrays
- ‚úÖ Solve items - Basic satisfy support
- ‚úÖ Solution extraction - TranslatedModel with variable mappings

### Phase 1: Constraints ‚úÖ (Partial)
- ‚úÖ `alldifferent` / `all_different`
- ‚úÖ Binary comparison constraints (`<`, `<=`, `>`, `>=`, `==`, `!=`)
- ‚úÖ Arithmetic in constraints (`+`, `-`, `*`, `/`)
- ‚ùå `element` constraint - Phase 2
- ‚ùå `cumulative` - Phase 2
- ‚ùå `table` constraint - Phase 2
- ‚ùå Array operations (`sum`, `product`, etc.) - Phase 2

### Phase 1: Testing & Examples ‚úÖ
- ‚úÖ Unit tests - 22 tests passing
- ‚úÖ Integration tests - Parser demo, solver demos
- ‚úÖ Example programs:
  - ‚úÖ `solve_nqueens.rs` - Shows array solution extraction
  - ‚úÖ `queens4.rs` - Visual chessboard output
  - ‚úÖ `compiler_demo.rs` - Translation workflow
  - ‚úÖ `simple_constraints.rs` - Constraint examples
  - ‚úÖ `parser_demo.rs` - Parser testing
- ‚úÖ Documentation - This file!
- ‚úÖ Error messages - Clear with source location

## Example: N-Queens Model (Current Implementation)

### Input (MiniZinc) ‚úÖ
```minizinc
% N-Queens Problem - WORKS (column constraints only)
int: n = 4;

% Decision variables: queen position in each row
array[1..n] of var 1..n: queens;

% All queens in different columns
constraint alldifferent(queens);

% Diagonal constraints NOT YET SUPPORTED - Phase 2
% constraint forall(i in 1..n, j in i+1..n) (
%     queens[i] != queens[j] + (j - i) /\
%     queens[i] != queens[j] - (j - i)
% );

solve satisfy;

output ["queens = ", show(queens), "\n"];
```

### Rust Usage (Actual API) ‚úÖ
```rust
use zelen::{parse, Translator};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let source = r#"
        int: n = 4;
        array[1..n] of var 1..n: queens;
        constraint alldifferent(queens);
        solve satisfy;
    "#;

    // Parse MiniZinc to AST
    let ast = parse(source)?;
    
    // Translate AST to Selen Model (direct, not code generation!)
    let translated = Translator::translate_with_vars(&ast)?;
    
    // Solve the model
    match translated.model.solve() {
        Ok(solution) => {
            // Extract solution values using variable mappings
            if let Some(queens) = translated.int_var_arrays.get("queens") {
                print!("queens = [");
                for (i, var_id) in queens.iter().enumerate() {
                    if i > 0 { print!(", "); }
                    if let selen::variables::Val::ValI(val) = solution[*var_id] {
                        print!("{}", val);
                    }
                }
                println!("]");
            }
            
            println!("Stats: {} propagations, {} nodes, {:?}",
                solution.stats.propagation_count,
                solution.stats.node_count,
                solution.stats.solve_time
            );
        }
        Err(e) => {
            println!("No solution: {:?}", e);
        }
    }
    
    Ok(())
}
```

### What Works Now ‚úÖ
- ‚úÖ Parse MiniZinc directly
- ‚úÖ Build Selen Model objects (not strings!)
- ‚úÖ Execute immediately
- ‚úÖ Extract solution values
- ‚úÖ Access solve statistics

### What Doesn't Work Yet ‚ùå
- ‚ùå Diagonal constraints (need `forall` loops)
- ‚ùå Array indexing in constraints (`queens[i]`)
- ‚ùå Output formatting (manual extraction instead)
- ‚ùå Optimization objectives
- ‚ùå Boolean operations in constraints

## Success Metrics

### Phase 1 Status ‚úÖ (MVP Complete)
- ‚úÖ Can parse N-Queens (column constraints only)
- ‚úÖ Can translate and solve directly (no code generation!)
- ‚úÖ Can handle arrays with variable domains
- ‚úÖ Can evaluate parameter expressions
- ‚úÖ Error messages are clear with source locations
- ‚úÖ Architecture is solid and extensible
- ‚ö†Ô∏è Sudoku requires array indexing (Phase 2)
- ‚ö†Ô∏è Full N-Queens requires forall loops (Phase 2)
- ‚ö†Ô∏è Magic Square requires array operations (Phase 2)

### Quality Metrics Achieved:
- **Tests Passing**: 22/22 unit tests ‚úÖ
- **Error Handling**: Clear errors with line/column/caret ‚úÖ
- **Architecture**: Direct execution (no string generation) ‚úÖ
- **Examples**: 5 working examples demonstrating features ‚úÖ
- **Maintainability**: Clean separation (parser/translator/examples) ‚úÖ

### What Works:
1. ‚úÖ Integer variables with domains
2. ‚úÖ Integer arrays with constrained elements
3. ‚úÖ Parameters with compile-time evaluation
4. ‚úÖ Binary comparison constraints
5. ‚úÖ Arithmetic expressions in constraints
6. ‚úÖ Alldifferent global constraint
7. ‚úÖ Direct model execution
8. ‚úÖ Solution value extraction

### Next Steps (Phase 2):
1. ‚ùå Array indexing in constraints (`x[i]`)
2. ‚ùå Forall loops for diagonal constraints
3. ‚ùå Boolean variables and operations
4. ‚ùå Array aggregate functions (`sum`, `product`, etc.)
5. ‚ùå Element constraint
6. ‚ùå Optimization (minimize/maximize)
7. ‚ùå Output item formatting

## References

- [MiniZinc Specification](https://docs.minizinc.dev/en/stable/spec.html)
- [MiniZinc Tutorial](https://docs.minizinc.dev/en/stable/part_2_tutorial.html)
- [Selen API Documentation](../README.md)
- [FlatZinc Specification](https://docs.minizinc.dev/en/stable/fzn-spec.html) (for comparison)

## Appendix A: Grammar Subset (EBNF)

```ebnf
(* Core MiniZinc Subset Grammar *)

model ::= item*

item ::= var_decl ";"
       | constraint ";"
       | solve ";"
       | output ";"

var_decl ::= type_inst ":" ident [ "=" expr ]

type_inst ::= [ "var" | "par" ] base_type
            | "array" "[" index_set "]" "of" type_inst

base_type ::= "bool"
            | "int"
            | "float"
            | int_range
            | set_literal

int_range ::= int_expr ".." int_expr

constraint ::= "constraint" expr

solve ::= "solve" "satisfy"
        | "solve" "minimize" expr
        | "solve" "maximize" expr

output ::= "output" "[" string_expr_list "]"

expr ::= int_expr
       | bool_expr
       | array_expr
       | call_expr
       | ident
       | literal

(* More detailed rules in parser implementation *)
```

## Appendix B: Limitations & Workarounds

| Limitation | Workaround | Phase |
|------------|------------|-------|
| Multi-dim arrays | Use 1D with index calculations | Phase 2 |
| Enums | Use integers (1, 2, 3...) | Phase 2 |
| Set variables | Represent as boolean arrays | Phase 3 |
| User predicates | Inline manually | Phase 2 |
| Complex comprehensions | Expand to loops | Phase 2 |
| Option types | Use sentinel values (-1, etc.) | Phase 3 |

## Appendix C: FAQ

**Q: Why not support full MiniZinc?**  
A: Full MiniZinc is very complex. This subset covers most practical models while keeping implementation tractable.

**Q: How do I use features not in the subset?**  
A: Either wait for later phases, use FlatZinc fallback, or manually rewrite your model.

**Q: Will my FlatZinc models still work?**  
A: Yes! FlatZinc support remains as fallback for unsupported features.

**Q: What about MiniZinc library functions?**  
A: Phase 1 includes only built-in operations. Phase 2 will add common library predicates.

**Q: How is performance compared to FlatZinc?**  
A: Should be similar or better, as we avoid flattening overhead and preserve structure.

---

*This is a living document. Update as implementation progresses and requirements evolve.*
